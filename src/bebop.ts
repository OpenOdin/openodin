//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.2
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 21, 0, 0, 0, 76, 105, 109, 105, 116, 70, 105, 101, 108,
100, 0, 1, 0, 0, 6, 0, 0, 0, 0, 2, 110, 97, 109, 101, 0,
245, 255, 255, 255, 0, 108, 105, 109, 105, 116, 0, 253,
255, 255, 255, 0, 70, 105, 108, 116, 101, 114, 0, 1, 0, 0,
16, 0, 0, 0, 0, 4, 102, 105, 101, 108, 100, 0, 245, 255,
255, 255, 0, 111, 112, 101, 114, 97, 116, 111, 114, 0,
245, 255, 255, 255, 0, 99, 109, 112, 0, 245, 255, 255,
255, 0, 118, 97, 108, 117, 101, 0, 245, 255, 255, 255, 0,
77, 97, 116, 99, 104, 0, 1, 0, 0, 30, 0, 0, 0, 0, 10, 110,
111, 100, 101, 84, 121, 112, 101, 0, 242, 255, 255, 255,
0, 254, 255, 255, 255, 0, 102, 105, 108, 116, 101, 114,
115, 0, 242, 255, 255, 255, 0, 1, 0, 0, 0, 0, 108, 105,
109, 105, 116, 0, 250, 255, 255, 255, 0, 108, 105, 109,
105, 116, 70, 105, 101, 108, 100, 0, 0, 0, 0, 0, 0, 108,
101, 118, 101, 108, 0, 242, 255, 255, 255, 0, 253, 255,
255, 255, 0, 100, 105, 115, 99, 97, 114, 100, 0, 255, 255,
255, 255, 0, 98, 111, 116, 116, 111, 109, 0, 255, 255,
255, 255, 0, 105, 100, 0, 254, 255, 255, 255, 0, 114, 101,
113, 117, 105, 114, 101, 73, 100, 0, 254, 255, 255, 255,
0, 99, 117, 114, 115, 111, 114, 73, 100, 49, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 65, 108, 108, 111,
119, 69, 109, 98, 101, 100, 0, 1, 0, 0, 8, 0, 0, 0, 0, 2,
110, 111, 100, 101, 84, 121, 112, 101, 0, 242, 255, 255,
255, 0, 254, 255, 255, 255, 0, 102, 105, 108, 116, 101,
114, 115, 0, 242, 255, 255, 255, 0, 1, 0, 0, 0, 0, 70,
101, 116, 99, 104, 81, 117, 101, 114, 121, 0, 1, 0, 0, 65,
0, 0, 0, 0, 21, 100, 101, 112, 116, 104, 0, 250, 255, 255,
255, 0, 108, 105, 109, 105, 116, 0, 250, 255, 255, 255, 0,
99, 117, 116, 111, 102, 102, 84, 105, 109, 101, 0, 248,
255, 255, 255, 0, 114, 111, 111, 116, 78, 111, 100, 101,
73, 100, 49, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255,
0, 100, 105, 115, 99, 97, 114, 100, 82, 111, 111, 116, 0,
255, 255, 255, 255, 0, 112, 97, 114, 101, 110, 116, 73,
100, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0, 116,
97, 114, 103, 101, 116, 80, 117, 98, 108, 105, 99, 75,
101, 121, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0,
115, 111, 117, 114, 99, 101, 80, 117, 98, 108, 105, 99,
75, 101, 121, 0, 242, 255, 255, 255, 0, 254, 255, 255,
255, 0, 109, 97, 116, 99, 104, 0, 242, 255, 255, 255, 0,
2, 0, 0, 0, 0, 101, 109, 98, 101, 100, 0, 242, 255, 255,
255, 0, 3, 0, 0, 0, 0, 116, 114, 105, 103, 103, 101, 114,
78, 111, 100, 101, 73, 100, 0, 242, 255, 255, 255, 0, 254,
255, 255, 255, 0, 116, 114, 105, 103, 103, 101, 114, 73,
110, 116, 101, 114, 118, 97, 108, 0, 253, 255, 255, 255,
0, 111, 110, 108, 121, 84, 114, 105, 103, 103, 101, 114,
0, 255, 255, 255, 255, 0, 100, 101, 115, 99, 101, 110,
100, 105, 110, 103, 0, 255, 255, 255, 255, 0, 111, 114,
100, 101, 114, 66, 121, 83, 116, 111, 114, 97, 103, 101,
84, 105, 109, 101, 0, 255, 255, 255, 255, 0, 105, 103,
110, 111, 114, 101, 73, 110, 97, 99, 116, 105, 118, 101,
0, 255, 255, 255, 255, 0, 105, 103, 110, 111, 114, 101,
79, 119, 110, 0, 255, 255, 255, 255, 0, 112, 114, 101,
115, 101, 114, 118, 101, 84, 114, 97, 110, 115, 105, 101,
110, 116, 0, 255, 255, 255, 255, 0, 114, 101, 103, 105,
111, 110, 0, 245, 255, 255, 255, 0, 106, 117, 114, 105,
115, 100, 105, 99, 116, 105, 111, 110, 0, 245, 255, 255,
255, 0, 105, 110, 99, 108, 117, 100, 101, 76, 105, 99,
101, 110, 115, 101, 115, 0, 245, 255, 255, 255, 0, 70,
101, 116, 99, 104, 67, 82, 68, 84, 0, 1, 0, 0, 29, 0, 0,
0, 0, 8, 97, 108, 103, 111, 0, 245, 255, 255, 255, 0, 99,
111, 110, 102, 0, 245, 255, 255, 255, 0, 109, 115, 103,
73, 100, 0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0,
114, 101, 118, 101, 114, 115, 101, 0, 255, 255, 255, 255,
0, 104, 101, 97, 100, 0, 250, 255, 255, 255, 0, 116, 97,
105, 108, 0, 250, 255, 255, 255, 0, 99, 117, 114, 115,
111, 114, 73, 100, 49, 0, 242, 255, 255, 255, 0, 254, 255,
255, 255, 0, 99, 117, 114, 115, 111, 114, 73, 110, 100,
101, 120, 0, 250, 255, 255, 255, 0, 83, 116, 97, 116, 117,
115, 0, 4, 0, 251, 255, 255, 255, 0, 4, 0, 0, 0, 12, 82,
101, 115, 117, 108, 116, 0, 0, 1, 0, 0, 0, 77, 97, 108,
102, 111, 114, 109, 101, 100, 0, 0, 2, 0, 0, 0, 69, 114,
114, 111, 114, 0, 0, 3, 0, 0, 0, 83, 116, 111, 114, 101,
70, 97, 105, 108, 101, 100, 0, 0, 4, 0, 0, 0, 70, 101,
116, 99, 104, 70, 97, 105, 108, 101, 100, 0, 0, 5, 0, 0,
0, 77, 105, 115, 115, 105, 110, 103, 82, 111, 111, 116,
110, 111, 100, 101, 0, 0, 6, 0, 0, 0, 82, 111, 111, 116,
110, 111, 100, 101, 76, 105, 99, 101, 110, 115, 101, 100,
0, 0, 7, 0, 0, 0, 78, 111, 116, 65, 108, 108, 111, 119,
101, 100, 0, 0, 8, 0, 0, 0, 77, 105, 115, 109, 97, 116,
99, 104, 0, 0, 9, 0, 0, 0, 69, 120, 105, 115, 116, 115, 0,
0, 10, 0, 0, 0, 77, 105, 115, 115, 105, 110, 103, 67, 117,
114, 115, 111, 114, 0, 0, 11, 0, 0, 0, 68, 114, 111, 112,
112, 101, 100, 84, 114, 105, 103, 103, 101, 114, 0, 0, 12,
0, 0, 0, 70, 101, 116, 99, 104, 82, 101, 115, 117, 108,
116, 0, 1, 0, 0, 16, 0, 0, 0, 0, 3, 110, 111, 100, 101,
115, 0, 242, 255, 255, 255, 1, 254, 255, 255, 255, 0, 101,
109, 98, 101, 100, 0, 242, 255, 255, 255, 1, 254, 255,
255, 255, 0, 99, 117, 116, 111, 102, 102, 84, 105, 109,
101, 0, 248, 255, 255, 255, 0, 67, 82, 68, 84, 82, 101,
115, 117, 108, 116, 0, 1, 0, 0, 12, 0, 0, 0, 0, 3, 100,
101, 108, 116, 97, 0, 242, 255, 255, 255, 0, 254, 255,
255, 255, 0, 99, 117, 114, 115, 111, 114, 73, 110, 100,
101, 120, 0, 250, 255, 255, 255, 0, 108, 101, 110, 103,
116, 104, 0, 251, 255, 255, 255, 0, 66, 111, 112, 70, 101,
116, 99, 104, 82, 101, 113, 117, 101, 115, 116, 0, 1, 1,
111, 112, 99, 111, 100, 101, 0, 1, 102, 111, 117, 114, 99,
99, 0, 245, 255, 255, 255, 48, 120, 49, 0, 0, 94, 0, 0, 0,
0, 2, 113, 117, 101, 114, 121, 0, 4, 0, 0, 0, 0, 99, 114,
100, 116, 0, 5, 0, 0, 0, 0, 66, 111, 112, 70, 101, 116,
99, 104, 82, 101, 115, 112, 111, 110, 115, 101, 0, 1, 1,
111, 112, 99, 111, 100, 101, 0, 1, 102, 111, 117, 114, 99,
99, 0, 245, 255, 255, 255, 48, 120, 50, 0, 0, 42, 0, 0, 0,
0, 7, 115, 116, 97, 116, 117, 115, 0, 6, 0, 0, 0, 0, 114,
101, 115, 117, 108, 116, 0, 7, 0, 0, 0, 0, 99, 114, 100,
116, 82, 101, 115, 117, 108, 116, 0, 8, 0, 0, 0, 0, 115,
101, 113, 0, 253, 255, 255, 255, 0, 101, 110, 100, 83,
101, 113, 0, 253, 255, 255, 255, 0, 114, 111, 119, 67,
111, 117, 110, 116, 0, 253, 255, 255, 255, 0, 101, 114,
114, 111, 114, 0, 245, 255, 255, 255, 0, 66, 111, 112, 83,
116, 111, 114, 101, 82, 101, 113, 117, 101, 115, 116, 0,
1, 1, 111, 112, 99, 111, 100, 101, 0, 1, 102, 111, 117,
114, 99, 99, 0, 245, 255, 255, 255, 48, 120, 51, 0, 0, 22,
0, 0, 0, 0, 7, 110, 111, 100, 101, 115, 0, 242, 255, 255,
255, 1, 254, 255, 255, 255, 0, 115, 111, 117, 114, 99,
101, 80, 117, 98, 108, 105, 99, 75, 101, 121, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 116, 97, 114, 103,
101, 116, 80, 117, 98, 108, 105, 99, 75, 101, 121, 0, 242,
255, 255, 255, 0, 254, 255, 255, 255, 0, 109, 117, 116,
101, 77, 115, 103, 73, 100, 115, 0, 242, 255, 255, 255, 1,
254, 255, 255, 255, 0, 112, 114, 101, 115, 101, 114, 118,
101, 84, 114, 97, 110, 115, 105, 101, 110, 116, 0, 255,
255, 255, 255, 0, 98, 97, 116, 99, 104, 73, 100, 0, 251,
255, 255, 255, 0, 104, 97, 115, 77, 111, 114, 101, 0, 255,
255, 255, 255, 0, 66, 111, 112, 83, 116, 111, 114, 101,
82, 101, 115, 112, 111, 110, 115, 101, 0, 1, 1, 111, 112,
99, 111, 100, 101, 0, 1, 102, 111, 117, 114, 99, 99, 0,
245, 255, 255, 255, 48, 120, 52, 0, 0, 20, 0, 0, 0, 0, 5,
115, 116, 97, 116, 117, 115, 0, 6, 0, 0, 0, 0, 115, 116,
111, 114, 101, 100, 73, 100, 49, 76, 105, 115, 116, 0,
242, 255, 255, 255, 1, 254, 255, 255, 255, 0, 109, 105,
115, 115, 105, 110, 103, 66, 108, 111, 98, 73, 100, 49,
76, 105, 115, 116, 0, 242, 255, 255, 255, 1, 254, 255,
255, 255, 0, 109, 105, 115, 115, 105, 110, 103, 66, 108,
111, 98, 83, 105, 122, 101, 115, 0, 242, 255, 255, 255, 0,
248, 255, 255, 255, 0, 101, 114, 114, 111, 114, 0, 245,
255, 255, 255, 0, 66, 111, 112, 85, 110, 115, 117, 98,
115, 99, 114, 105, 98, 101, 82, 101, 113, 117, 101, 115,
116, 0, 1, 1, 111, 112, 99, 111, 100, 101, 0, 1, 102, 111,
117, 114, 99, 99, 0, 245, 255, 255, 255, 48, 120, 53, 0,
0, 8, 0, 0, 0, 0, 2, 111, 114, 105, 103, 105, 110, 97,
108, 77, 115, 103, 73, 100, 0, 242, 255, 255, 255, 0, 254,
255, 255, 255, 0, 116, 97, 114, 103, 101, 116, 80, 117,
98, 108, 105, 99, 75, 101, 121, 0, 242, 255, 255, 255, 0,
254, 255, 255, 255, 0, 66, 111, 112, 85, 110, 115, 117,
98, 115, 99, 114, 105, 98, 101, 82, 101, 115, 112, 111,
110, 115, 101, 0, 1, 1, 111, 112, 99, 111, 100, 101, 0, 1,
102, 111, 117, 114, 99, 99, 0, 245, 255, 255, 255, 48,
120, 54, 0, 0, 8, 0, 0, 0, 0, 2, 115, 116, 97, 116, 117,
115, 0, 6, 0, 0, 0, 0, 101, 114, 114, 111, 114, 0, 245,
255, 255, 255, 0, 66, 111, 112, 87, 114, 105, 116, 101,
66, 108, 111, 98, 82, 101, 113, 117, 101, 115, 116, 0, 1,
1, 111, 112, 99, 111, 100, 101, 0, 1, 102, 111, 117, 114,
99, 99, 0, 245, 255, 255, 255, 48, 120, 55, 0, 0, 28, 0,
0, 0, 0, 6, 110, 111, 100, 101, 73, 100, 49, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 112, 111, 115, 0, 249,
255, 255, 255, 0, 100, 97, 116, 97, 0, 242, 255, 255, 255,
0, 254, 255, 255, 255, 0, 115, 111, 117, 114, 99, 101, 80,
117, 98, 108, 105, 99, 75, 101, 121, 0, 242, 255, 255,
255, 0, 254, 255, 255, 255, 0, 116, 97, 114, 103, 101,
116, 80, 117, 98, 108, 105, 99, 75, 101, 121, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 109, 117, 116, 101,
77, 115, 103, 73, 100, 115, 0, 242, 255, 255, 255, 1, 254,
255, 255, 255, 0, 66, 111, 112, 87, 114, 105, 116, 101,
66, 108, 111, 98, 82, 101, 115, 112, 111, 110, 115, 101,
0, 1, 1, 111, 112, 99, 111, 100, 101, 0, 1, 102, 111, 117,
114, 99, 99, 0, 245, 255, 255, 255, 48, 120, 56, 0, 0, 16,
0, 0, 0, 0, 3, 115, 116, 97, 116, 117, 115, 0, 6, 0, 0, 0,
0, 99, 117, 114, 114, 101, 110, 116, 76, 101, 110, 103,
116, 104, 0, 249, 255, 255, 255, 0, 101, 114, 114, 111,
114, 0, 245, 255, 255, 255, 0, 66, 111, 112, 82, 101, 97,
100, 66, 108, 111, 98, 82, 101, 113, 117, 101, 115, 116,
0, 1, 1, 111, 112, 99, 111, 100, 101, 0, 1, 102, 111, 117,
114, 99, 99, 0, 245, 255, 255, 255, 48, 120, 57, 0, 0, 24,
0, 0, 0, 0, 5, 110, 111, 100, 101, 73, 100, 49, 0, 242,
255, 255, 255, 0, 254, 255, 255, 255, 0, 112, 111, 115, 0,
249, 255, 255, 255, 0, 108, 101, 110, 103, 116, 104, 0,
251, 255, 255, 255, 0, 116, 97, 114, 103, 101, 116, 80,
117, 98, 108, 105, 99, 75, 101, 121, 0, 242, 255, 255,
255, 0, 254, 255, 255, 255, 0, 115, 111, 117, 114, 99,
101, 80, 117, 98, 108, 105, 99, 75, 101, 121, 0, 242, 255,
255, 255, 0, 254, 255, 255, 255, 0, 66, 111, 112, 82, 101,
97, 100, 66, 108, 111, 98, 82, 101, 115, 112, 111, 110,
115, 101, 0, 1, 1, 111, 112, 99, 111, 100, 101, 0, 1, 102,
111, 117, 114, 99, 99, 0, 245, 255, 255, 255, 48, 120, 65,
0, 0, 24, 0, 0, 0, 0, 6, 115, 116, 97, 116, 117, 115, 0,
6, 0, 0, 0, 0, 100, 97, 116, 97, 0, 242, 255, 255, 255, 0,
254, 255, 255, 255, 0, 115, 101, 113, 0, 253, 255, 255,
255, 0, 101, 110, 100, 83, 101, 113, 0, 253, 255, 255,
255, 0, 98, 108, 111, 98, 76, 101, 110, 103, 116, 104, 0,
249, 255, 255, 255, 0, 101, 114, 114, 111, 114, 0, 245,
255, 255, 255, 0, 66, 111, 112, 71, 101, 110, 101, 114,
105, 99, 77, 101, 115, 115, 97, 103, 101, 82, 101, 113,
117, 101, 115, 116, 0, 1, 1, 111, 112, 99, 111, 100, 101,
0, 1, 102, 111, 117, 114, 99, 99, 0, 245, 255, 255, 255,
48, 120, 66, 0, 0, 12, 0, 0, 0, 0, 3, 97, 99, 116, 105,
111, 110, 0, 245, 255, 255, 255, 0, 115, 111, 117, 114,
99, 101, 80, 117, 98, 108, 105, 99, 75, 101, 121, 0, 242,
255, 255, 255, 0, 254, 255, 255, 255, 0, 100, 97, 116, 97,
0, 242, 255, 255, 255, 0, 254, 255, 255, 255, 0, 66, 111,
112, 71, 101, 110, 101, 114, 105, 99, 77, 101, 115, 115,
97, 103, 101, 82, 101, 115, 112, 111, 110, 115, 101, 0, 1,
1, 111, 112, 99, 111, 100, 101, 0, 1, 102, 111, 117, 114,
99, 99, 0, 245, 255, 255, 255, 48, 120, 67, 0, 0, 12, 0,
0, 0, 0, 3, 115, 116, 97, 116, 117, 115, 0, 6, 0, 0, 0, 0,
100, 97, 116, 97, 0, 242, 255, 255, 255, 0, 254, 255, 255,
255, 0, 101, 114, 114, 111, 114, 0, 245, 255, 255, 255, 0,
0, 0, 0, 0
]);

export interface ILimitField extends BebopRecord {

  readonly name: string;

  readonly limit: number;
}

export class LimitField implements ILimitField {
  public readonly name: string;
  public readonly limit: number;

  constructor(record: ILimitField) {
    this.name = record.name;
    this.limit = record.limit;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return LimitField.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ILimitField): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    LimitField.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link LimitField}.
   */
  public static validateCompatibility(record: ILimitField): void {
    BebopTypeGuard.ensureString(record.name)
    BebopTypeGuard.ensureUint16(record.limit)
  }

  /**
   * Unsafely creates an instance of {@link LimitField} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ILimitField {
      return new LimitField(record);
  }

  /**
   * Creates a new {@link LimitField} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ILimitField {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`LimitField.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    LimitField.validateCompatibility(parsed);
    return LimitField.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return LimitField.encode(this);
  }

  public static encode(record: ILimitField): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    LimitField.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ILimitField, view: BebopView): number {
    const before = view.length;
    view.writeString(record.name);
    view.writeUint16(record.limit);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ILimitField {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return LimitField.readFrom(view);
  }

  public static readFrom(view: BebopView): ILimitField {
    let field0: string;
    field0 = view.readString();
    let field1: number;
    field1 = view.readUint16();
    let message: ILimitField = {
      name: field0,
      limit: field1,
    };
    return new LimitField(message);
  }
}

/**
 * This struct matched Filter in datamodel/model/types.ts.
 */
export interface IFilter extends BebopRecord {

  readonly field: string;

  readonly operator: string;

  readonly cmp: string;

  readonly value: string;
}

export class Filter implements IFilter {
  public readonly field: string;
  public readonly operator: string;
  public readonly cmp: string;
  public readonly value: string;

  constructor(record: IFilter) {
    this.field = record.field;
    this.operator = record.operator;
    this.cmp = record.cmp;
    this.value = record.value;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Filter.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IFilter): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Filter.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Filter}.
   */
  public static validateCompatibility(record: IFilter): void {
    BebopTypeGuard.ensureString(record.field)
    BebopTypeGuard.ensureString(record.operator)
    BebopTypeGuard.ensureString(record.cmp)
    BebopTypeGuard.ensureString(record.value)
  }

  /**
   * Unsafely creates an instance of {@link Filter} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IFilter {
      return new Filter(record);
  }

  /**
   * Creates a new {@link Filter} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IFilter {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Filter.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Filter.validateCompatibility(parsed);
    return Filter.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Filter.encode(this);
  }

  public static encode(record: IFilter): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Filter.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IFilter, view: BebopView): number {
    const before = view.length;
    view.writeString(record.field);
    view.writeString(record.operator);
    view.writeString(record.cmp);
    view.writeString(record.value);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IFilter {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Filter.readFrom(view);
  }

  public static readFrom(view: BebopView): IFilter {
    let field0: string;
    field0 = view.readString();
    let field1: string;
    field1 = view.readString();
    let field2: string;
    field2 = view.readString();
    let field3: string;
    field3 = view.readString();
    let message: IFilter = {
      field: field0,
      operator: field1,
      cmp: field2,
      value: field3,
    };
    return new Filter(message);
  }
}


export interface IMatch extends BebopRecord {

  readonly nodeType: Uint8Array;

  readonly filters: Array<IFilter>;

  readonly limit: number;

  readonly limitField: ILimitField;

  readonly level: Array<number>;

  readonly discard: boolean;

  readonly bottom: boolean;

  readonly id: number;

  readonly requireId: number;

  readonly cursorId1: Uint8Array;
}

export class Match implements IMatch {
  public readonly nodeType: Uint8Array;
  public readonly filters: Array<IFilter>;
  public readonly limit: number;
  public readonly limitField: ILimitField;
  public readonly level: Array<number>;
  public readonly discard: boolean;
  public readonly bottom: boolean;
  public readonly id: number;
  public readonly requireId: number;
  public readonly cursorId1: Uint8Array;

  constructor(record: IMatch) {
    this.nodeType = record.nodeType;
    this.filters = record.filters;
    this.limit = record.limit;
    this.limitField = record.limitField;
    this.level = record.level;
    this.discard = record.discard;
    this.bottom = record.bottom;
    this.id = record.id;
    this.requireId = record.requireId;
    this.cursorId1 = record.cursorId1;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Match.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IMatch): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Match.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Match}.
   */
  public static validateCompatibility(record: IMatch): void {
    BebopTypeGuard.ensureArray(record.nodeType, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.filters, Filter.validateCompatibility);
    BebopTypeGuard.ensureInt32(record.limit)
    LimitField.validateCompatibility(record.limitField);
    BebopTypeGuard.ensureArray(record.level, BebopTypeGuard.ensureUint16);
    BebopTypeGuard.ensureBoolean(record.discard)
    BebopTypeGuard.ensureBoolean(record.bottom)
    BebopTypeGuard.ensureUint8(record.id)
    BebopTypeGuard.ensureUint8(record.requireId)
    BebopTypeGuard.ensureArray(record.cursorId1, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link Match} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IMatch {
      record.limitField = LimitField.unsafeCast(record.limitField);
      return new Match(record);
  }

  /**
   * Creates a new {@link Match} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IMatch {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Match.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Match.validateCompatibility(parsed);
    return Match.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Match.encode(this);
  }

  public static encode(record: IMatch): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Match.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IMatch, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.nodeType);
    {
      const length0 = record.filters.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Filter.encodeInto(record.filters[i0], view)
      }
    }
    view.writeInt32(record.limit);
    LimitField.encodeInto(record.limitField, view)
    {
      const length0 = record.level.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeUint16(record.level[i0]);
      }
    }
    view.writeByte(Number(record.discard));
    view.writeByte(Number(record.bottom));
    view.writeByte(record.id);
    view.writeByte(record.requireId);
    view.writeBytes(record.cursorId1);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IMatch {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Match.readFrom(view);
  }

  public static readFrom(view: BebopView): IMatch {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Array<IFilter>;
    {
      let length0 = view.readUint32();
      field1 = new Array<IFilter>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IFilter;
        x0 = Filter.readFrom(view);
        field1[i0] = x0;
      }
    }
    let field2: number;
    field2 = view.readInt32();
    let field3: ILimitField;
    field3 = LimitField.readFrom(view);
    let field4: Array<number>;
    {
      let length0 = view.readUint32();
      field4 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readUint16();
        field4[i0] = x0;
      }
    }
    let field5: boolean;
    field5 = !!view.readByte();
    let field6: boolean;
    field6 = !!view.readByte();
    let field7: number;
    field7 = view.readByte();
    let field8: number;
    field8 = view.readByte();
    let field9: Uint8Array;
    field9 = view.readBytes();
    let message: IMatch = {
      nodeType: field0,
      filters: field1,
      limit: field2,
      limitField: field3,
      level: field4,
      discard: field5,
      bottom: field6,
      id: field7,
      requireId: field8,
      cursorId1: field9,
    };
    return new Match(message);
  }
}


export interface IAllowEmbed extends BebopRecord {

  readonly nodeType: Uint8Array;

  readonly filters: Array<IFilter>;
}

export class AllowEmbed implements IAllowEmbed {
  public readonly nodeType: Uint8Array;
  public readonly filters: Array<IFilter>;

  constructor(record: IAllowEmbed) {
    this.nodeType = record.nodeType;
    this.filters = record.filters;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return AllowEmbed.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IAllowEmbed): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    AllowEmbed.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link AllowEmbed}.
   */
  public static validateCompatibility(record: IAllowEmbed): void {
    BebopTypeGuard.ensureArray(record.nodeType, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.filters, Filter.validateCompatibility);
  }

  /**
   * Unsafely creates an instance of {@link AllowEmbed} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IAllowEmbed {
      return new AllowEmbed(record);
  }

  /**
   * Creates a new {@link AllowEmbed} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IAllowEmbed {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`AllowEmbed.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    AllowEmbed.validateCompatibility(parsed);
    return AllowEmbed.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return AllowEmbed.encode(this);
  }

  public static encode(record: IAllowEmbed): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    AllowEmbed.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IAllowEmbed, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.nodeType);
    {
      const length0 = record.filters.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Filter.encodeInto(record.filters[i0], view)
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IAllowEmbed {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return AllowEmbed.readFrom(view);
  }

  public static readFrom(view: BebopView): IAllowEmbed {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Array<IFilter>;
    {
      let length0 = view.readUint32();
      field1 = new Array<IFilter>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IFilter;
        x0 = Filter.readFrom(view);
        field1[i0] = x0;
      }
    }
    let message: IAllowEmbed = {
      nodeType: field0,
      filters: field1,
    };
    return new AllowEmbed(message);
  }
}


export interface IFetchQuery extends BebopRecord {

  readonly depth: number;

  readonly limit: number;

  readonly cutoffTime: bigint;

  readonly rootNodeId1: Uint8Array;

  readonly discardRoot: boolean;

  readonly parentId: Uint8Array;

  readonly targetPublicKey: Uint8Array;

  readonly sourcePublicKey: Uint8Array;

  readonly match: Array<IMatch>;

  readonly embed: Array<IAllowEmbed>;

  readonly triggerNodeId: Uint8Array;

  readonly triggerInterval: number;

  readonly onlyTrigger: boolean;

  readonly descending: boolean;

  readonly orderByStorageTime: boolean;

  readonly ignoreInactive: boolean;

  readonly ignoreOwn: boolean;

  readonly preserveTransient: boolean;

  readonly region: string;

  readonly jurisdiction: string;

  readonly includeLicenses: string;
}

export class FetchQuery implements IFetchQuery {
  public readonly depth: number;
  public readonly limit: number;
  public readonly cutoffTime: bigint;
  public readonly rootNodeId1: Uint8Array;
  public readonly discardRoot: boolean;
  public readonly parentId: Uint8Array;
  public readonly targetPublicKey: Uint8Array;
  public readonly sourcePublicKey: Uint8Array;
  public readonly match: Array<IMatch>;
  public readonly embed: Array<IAllowEmbed>;
  public readonly triggerNodeId: Uint8Array;
  public readonly triggerInterval: number;
  public readonly onlyTrigger: boolean;
  public readonly descending: boolean;
  public readonly orderByStorageTime: boolean;
  public readonly ignoreInactive: boolean;
  public readonly ignoreOwn: boolean;
  public readonly preserveTransient: boolean;
  public readonly region: string;
  public readonly jurisdiction: string;
  public readonly includeLicenses: string;

  constructor(record: IFetchQuery) {
    this.depth = record.depth;
    this.limit = record.limit;
    this.cutoffTime = record.cutoffTime;
    this.rootNodeId1 = record.rootNodeId1;
    this.discardRoot = record.discardRoot;
    this.parentId = record.parentId;
    this.targetPublicKey = record.targetPublicKey;
    this.sourcePublicKey = record.sourcePublicKey;
    this.match = record.match;
    this.embed = record.embed;
    this.triggerNodeId = record.triggerNodeId;
    this.triggerInterval = record.triggerInterval;
    this.onlyTrigger = record.onlyTrigger;
    this.descending = record.descending;
    this.orderByStorageTime = record.orderByStorageTime;
    this.ignoreInactive = record.ignoreInactive;
    this.ignoreOwn = record.ignoreOwn;
    this.preserveTransient = record.preserveTransient;
    this.region = record.region;
    this.jurisdiction = record.jurisdiction;
    this.includeLicenses = record.includeLicenses;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return FetchQuery.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IFetchQuery): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    FetchQuery.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link FetchQuery}.
   */
  public static validateCompatibility(record: IFetchQuery): void {
    BebopTypeGuard.ensureInt32(record.depth)
    BebopTypeGuard.ensureInt32(record.limit)
    BebopTypeGuard.ensureInt64(record.cutoffTime)
    BebopTypeGuard.ensureArray(record.rootNodeId1, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureBoolean(record.discardRoot)
    BebopTypeGuard.ensureArray(record.parentId, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.targetPublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.sourcePublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.match, Match.validateCompatibility);
    BebopTypeGuard.ensureArray(record.embed, AllowEmbed.validateCompatibility);
    BebopTypeGuard.ensureArray(record.triggerNodeId, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureUint16(record.triggerInterval)
    BebopTypeGuard.ensureBoolean(record.onlyTrigger)
    BebopTypeGuard.ensureBoolean(record.descending)
    BebopTypeGuard.ensureBoolean(record.orderByStorageTime)
    BebopTypeGuard.ensureBoolean(record.ignoreInactive)
    BebopTypeGuard.ensureBoolean(record.ignoreOwn)
    BebopTypeGuard.ensureBoolean(record.preserveTransient)
    BebopTypeGuard.ensureString(record.region)
    BebopTypeGuard.ensureString(record.jurisdiction)
    BebopTypeGuard.ensureString(record.includeLicenses)
  }

  /**
   * Unsafely creates an instance of {@link FetchQuery} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IFetchQuery {
      return new FetchQuery(record);
  }

  /**
   * Creates a new {@link FetchQuery} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IFetchQuery {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`FetchQuery.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    FetchQuery.validateCompatibility(parsed);
    return FetchQuery.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return FetchQuery.encode(this);
  }

  public static encode(record: IFetchQuery): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    FetchQuery.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IFetchQuery, view: BebopView): number {
    const before = view.length;
    view.writeInt32(record.depth);
    view.writeInt32(record.limit);
    view.writeInt64(record.cutoffTime);
    view.writeBytes(record.rootNodeId1);
    view.writeByte(Number(record.discardRoot));
    view.writeBytes(record.parentId);
    view.writeBytes(record.targetPublicKey);
    view.writeBytes(record.sourcePublicKey);
    {
      const length0 = record.match.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Match.encodeInto(record.match[i0], view)
      }
    }
    {
      const length0 = record.embed.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        AllowEmbed.encodeInto(record.embed[i0], view)
      }
    }
    view.writeBytes(record.triggerNodeId);
    view.writeUint16(record.triggerInterval);
    view.writeByte(Number(record.onlyTrigger));
    view.writeByte(Number(record.descending));
    view.writeByte(Number(record.orderByStorageTime));
    view.writeByte(Number(record.ignoreInactive));
    view.writeByte(Number(record.ignoreOwn));
    view.writeByte(Number(record.preserveTransient));
    view.writeString(record.region);
    view.writeString(record.jurisdiction);
    view.writeString(record.includeLicenses);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IFetchQuery {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return FetchQuery.readFrom(view);
  }

  public static readFrom(view: BebopView): IFetchQuery {
    let field0: number;
    field0 = view.readInt32();
    let field1: number;
    field1 = view.readInt32();
    let field2: bigint;
    field2 = view.readInt64();
    let field3: Uint8Array;
    field3 = view.readBytes();
    let field4: boolean;
    field4 = !!view.readByte();
    let field5: Uint8Array;
    field5 = view.readBytes();
    let field6: Uint8Array;
    field6 = view.readBytes();
    let field7: Uint8Array;
    field7 = view.readBytes();
    let field8: Array<IMatch>;
    {
      let length0 = view.readUint32();
      field8 = new Array<IMatch>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IMatch;
        x0 = Match.readFrom(view);
        field8[i0] = x0;
      }
    }
    let field9: Array<IAllowEmbed>;
    {
      let length0 = view.readUint32();
      field9 = new Array<IAllowEmbed>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IAllowEmbed;
        x0 = AllowEmbed.readFrom(view);
        field9[i0] = x0;
      }
    }
    let field10: Uint8Array;
    field10 = view.readBytes();
    let field11: number;
    field11 = view.readUint16();
    let field12: boolean;
    field12 = !!view.readByte();
    let field13: boolean;
    field13 = !!view.readByte();
    let field14: boolean;
    field14 = !!view.readByte();
    let field15: boolean;
    field15 = !!view.readByte();
    let field16: boolean;
    field16 = !!view.readByte();
    let field17: boolean;
    field17 = !!view.readByte();
    let field18: string;
    field18 = view.readString();
    let field19: string;
    field19 = view.readString();
    let field20: string;
    field20 = view.readString();
    let message: IFetchQuery = {
      depth: field0,
      limit: field1,
      cutoffTime: field2,
      rootNodeId1: field3,
      discardRoot: field4,
      parentId: field5,
      targetPublicKey: field6,
      sourcePublicKey: field7,
      match: field8,
      embed: field9,
      triggerNodeId: field10,
      triggerInterval: field11,
      onlyTrigger: field12,
      descending: field13,
      orderByStorageTime: field14,
      ignoreInactive: field15,
      ignoreOwn: field16,
      preserveTransient: field17,
      region: field18,
      jurisdiction: field19,
      includeLicenses: field20,
    };
    return new FetchQuery(message);
  }
}


export interface IFetchCRDT extends BebopRecord {

  readonly algo: string;

  readonly conf: string;

  readonly msgId: Uint8Array;

  readonly reverse: boolean;

  readonly head: number;

  readonly tail: number;

  readonly cursorId1: Uint8Array;

  readonly cursorIndex: number;
}

export class FetchCRDT implements IFetchCRDT {
  public readonly algo: string;
  public readonly conf: string;
  public readonly msgId: Uint8Array;
  public readonly reverse: boolean;
  public readonly head: number;
  public readonly tail: number;
  public readonly cursorId1: Uint8Array;
  public readonly cursorIndex: number;

  constructor(record: IFetchCRDT) {
    this.algo = record.algo;
    this.conf = record.conf;
    this.msgId = record.msgId;
    this.reverse = record.reverse;
    this.head = record.head;
    this.tail = record.tail;
    this.cursorId1 = record.cursorId1;
    this.cursorIndex = record.cursorIndex;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return FetchCRDT.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IFetchCRDT): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    FetchCRDT.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link FetchCRDT}.
   */
  public static validateCompatibility(record: IFetchCRDT): void {
    BebopTypeGuard.ensureString(record.algo)
    BebopTypeGuard.ensureString(record.conf)
    BebopTypeGuard.ensureArray(record.msgId, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureBoolean(record.reverse)
    BebopTypeGuard.ensureInt32(record.head)
    BebopTypeGuard.ensureInt32(record.tail)
    BebopTypeGuard.ensureArray(record.cursorId1, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureInt32(record.cursorIndex)
  }

  /**
   * Unsafely creates an instance of {@link FetchCRDT} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IFetchCRDT {
      return new FetchCRDT(record);
  }

  /**
   * Creates a new {@link FetchCRDT} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IFetchCRDT {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`FetchCRDT.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    FetchCRDT.validateCompatibility(parsed);
    return FetchCRDT.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return FetchCRDT.encode(this);
  }

  public static encode(record: IFetchCRDT): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    FetchCRDT.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IFetchCRDT, view: BebopView): number {
    const before = view.length;
    view.writeString(record.algo);
    view.writeString(record.conf);
    view.writeBytes(record.msgId);
    view.writeByte(Number(record.reverse));
    view.writeInt32(record.head);
    view.writeInt32(record.tail);
    view.writeBytes(record.cursorId1);
    view.writeInt32(record.cursorIndex);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IFetchCRDT {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return FetchCRDT.readFrom(view);
  }

  public static readFrom(view: BebopView): IFetchCRDT {
    let field0: string;
    field0 = view.readString();
    let field1: string;
    field1 = view.readString();
    let field2: Uint8Array;
    field2 = view.readBytes();
    let field3: boolean;
    field3 = !!view.readByte();
    let field4: number;
    field4 = view.readInt32();
    let field5: number;
    field5 = view.readInt32();
    let field6: Uint8Array;
    field6 = view.readBytes();
    let field7: number;
    field7 = view.readInt32();
    let message: IFetchCRDT = {
      algo: field0,
      conf: field1,
      msgId: field2,
      reverse: field3,
      head: field4,
      tail: field5,
      cursorId1: field6,
      cursorIndex: field7,
    };
    return new FetchCRDT(message);
  }
}


export enum Status {

  Result = 1,

  Malformed = 2,

  Error = 3,

  StoreFailed = 4,

  FetchFailed = 5,

  MissingRootnode = 6,

  RootnodeLicensed = 7,

  NotAllowed = 8,

  Mismatch = 9,

  Exists = 10,

  MissingCursor = 11,

  DroppedTrigger = 12,
}


export interface IFetchResult extends BebopRecord {

  readonly nodes: Array<Uint8Array>;

  readonly embed: Array<Uint8Array>;

  readonly cutoffTime: bigint;
}

export class FetchResult implements IFetchResult {
  public readonly nodes: Array<Uint8Array>;
  public readonly embed: Array<Uint8Array>;
  public readonly cutoffTime: bigint;

  constructor(record: IFetchResult) {
    this.nodes = record.nodes;
    this.embed = record.embed;
    this.cutoffTime = record.cutoffTime;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return FetchResult.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IFetchResult): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    FetchResult.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link FetchResult}.
   */
  public static validateCompatibility(record: IFetchResult): void {
    BebopTypeGuard.ensureArray(record.nodes, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureUint8));
    BebopTypeGuard.ensureArray(record.embed, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureUint8));
    BebopTypeGuard.ensureInt64(record.cutoffTime)
  }

  /**
   * Unsafely creates an instance of {@link FetchResult} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IFetchResult {
      return new FetchResult(record);
  }

  /**
   * Creates a new {@link FetchResult} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IFetchResult {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`FetchResult.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    FetchResult.validateCompatibility(parsed);
    return FetchResult.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return FetchResult.encode(this);
  }

  public static encode(record: IFetchResult): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    FetchResult.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IFetchResult, view: BebopView): number {
    const before = view.length;
    {
      const length0 = record.nodes.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeBytes(record.nodes[i0]);
      }
    }
    {
      const length0 = record.embed.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeBytes(record.embed[i0]);
      }
    }
    view.writeInt64(record.cutoffTime);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IFetchResult {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return FetchResult.readFrom(view);
  }

  public static readFrom(view: BebopView): IFetchResult {
    let field0: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field0 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field0[i0] = x0;
      }
    }
    let field1: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field1 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field1[i0] = x0;
      }
    }
    let field2: bigint;
    field2 = view.readInt64();
    let message: IFetchResult = {
      nodes: field0,
      embed: field1,
      cutoffTime: field2,
    };
    return new FetchResult(message);
  }
}


export interface ICRDTResult extends BebopRecord {

  readonly delta: Uint8Array;

  readonly cursorIndex: number;

  readonly length: number;
}

export class CRDTResult implements ICRDTResult {
  public readonly delta: Uint8Array;
  public readonly cursorIndex: number;
  public readonly length: number;

  constructor(record: ICRDTResult) {
    this.delta = record.delta;
    this.cursorIndex = record.cursorIndex;
    this.length = record.length;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return CRDTResult.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICRDTResult): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    CRDTResult.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link CRDTResult}.
   */
  public static validateCompatibility(record: ICRDTResult): void {
    BebopTypeGuard.ensureArray(record.delta, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureInt32(record.cursorIndex)
    BebopTypeGuard.ensureUint32(record.length)
  }

  /**
   * Unsafely creates an instance of {@link CRDTResult} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ICRDTResult {
      return new CRDTResult(record);
  }

  /**
   * Creates a new {@link CRDTResult} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ICRDTResult {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`CRDTResult.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    CRDTResult.validateCompatibility(parsed);
    return CRDTResult.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return CRDTResult.encode(this);
  }

  public static encode(record: ICRDTResult): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    CRDTResult.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICRDTResult, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.delta);
    view.writeInt32(record.cursorIndex);
    view.writeUint32(record.length);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ICRDTResult {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return CRDTResult.readFrom(view);
  }

  public static readFrom(view: BebopView): ICRDTResult {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: number;
    field1 = view.readInt32();
    let field2: number;
    field2 = view.readUint32();
    let message: ICRDTResult = {
      delta: field0,
      cursorIndex: field1,
      length: field2,
    };
    return new CRDTResult(message);
  }
}


export interface IBopFetchRequest extends BebopRecord {

  readonly query: IFetchQuery;

  readonly crdt: IFetchCRDT;
}

export class BopFetchRequest implements IBopFetchRequest {
  public static readonly opcode: number = 0x1 as 0x1;
  public readonly query: IFetchQuery;
  public readonly crdt: IFetchCRDT;

  constructor(record: IBopFetchRequest) {
    this.query = record.query;
    this.crdt = record.crdt;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopFetchRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopFetchRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopFetchRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopFetchRequest}.
   */
  public static validateCompatibility(record: IBopFetchRequest): void {
    FetchQuery.validateCompatibility(record.query);
    FetchCRDT.validateCompatibility(record.crdt);
  }

  /**
   * Unsafely creates an instance of {@link BopFetchRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopFetchRequest {
      record.query = FetchQuery.unsafeCast(record.query);
      record.crdt = FetchCRDT.unsafeCast(record.crdt);
      return new BopFetchRequest(record);
  }

  /**
   * Creates a new {@link BopFetchRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopFetchRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopFetchRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopFetchRequest.validateCompatibility(parsed);
    return BopFetchRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopFetchRequest.encode(this);
  }

  public static encode(record: IBopFetchRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopFetchRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopFetchRequest, view: BebopView): number {
    const before = view.length;
    FetchQuery.encodeInto(record.query, view)
    FetchCRDT.encodeInto(record.crdt, view)
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopFetchRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopFetchRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopFetchRequest {
    let field0: IFetchQuery;
    field0 = FetchQuery.readFrom(view);
    let field1: IFetchCRDT;
    field1 = FetchCRDT.readFrom(view);
    let message: IBopFetchRequest = {
      query: field0,
      crdt: field1,
    };
    return new BopFetchRequest(message);
  }
}


export interface IBopFetchResponse extends BebopRecord {

  readonly status: Status;

  readonly result: IFetchResult;

  readonly crdtResult: ICRDTResult;

  readonly seq: number;

  readonly endSeq: number;

  readonly rowCount: number;

  readonly error: string;
}

export class BopFetchResponse implements IBopFetchResponse {
  public static readonly opcode: number = 0x2 as 0x2;
  public readonly status: Status;
  public readonly result: IFetchResult;
  public readonly crdtResult: ICRDTResult;
  public readonly seq: number;
  public readonly endSeq: number;
  public readonly rowCount: number;
  public readonly error: string;

  constructor(record: IBopFetchResponse) {
    this.status = record.status;
    this.result = record.result;
    this.crdtResult = record.crdtResult;
    this.seq = record.seq;
    this.endSeq = record.endSeq;
    this.rowCount = record.rowCount;
    this.error = record.error;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopFetchResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopFetchResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopFetchResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopFetchResponse}.
   */
  public static validateCompatibility(record: IBopFetchResponse): void {
    BebopTypeGuard.ensureEnum(record.status, Status);
    FetchResult.validateCompatibility(record.result);
    CRDTResult.validateCompatibility(record.crdtResult);
    BebopTypeGuard.ensureUint16(record.seq)
    BebopTypeGuard.ensureUint16(record.endSeq)
    BebopTypeGuard.ensureUint16(record.rowCount)
    BebopTypeGuard.ensureString(record.error)
  }

  /**
   * Unsafely creates an instance of {@link BopFetchResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopFetchResponse {
      record.result = FetchResult.unsafeCast(record.result);
      record.crdtResult = CRDTResult.unsafeCast(record.crdtResult);
      return new BopFetchResponse(record);
  }

  /**
   * Creates a new {@link BopFetchResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopFetchResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopFetchResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopFetchResponse.validateCompatibility(parsed);
    return BopFetchResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopFetchResponse.encode(this);
  }

  public static encode(record: IBopFetchResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopFetchResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopFetchResponse, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.status);
    FetchResult.encodeInto(record.result, view)
    CRDTResult.encodeInto(record.crdtResult, view)
    view.writeUint16(record.seq);
    view.writeUint16(record.endSeq);
    view.writeUint16(record.rowCount);
    view.writeString(record.error);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopFetchResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopFetchResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopFetchResponse {
    let field0: Status;
    field0 = view.readUint32() as Status;
    let field1: IFetchResult;
    field1 = FetchResult.readFrom(view);
    let field2: ICRDTResult;
    field2 = CRDTResult.readFrom(view);
    let field3: number;
    field3 = view.readUint16();
    let field4: number;
    field4 = view.readUint16();
    let field5: number;
    field5 = view.readUint16();
    let field6: string;
    field6 = view.readString();
    let message: IBopFetchResponse = {
      status: field0,
      result: field1,
      crdtResult: field2,
      seq: field3,
      endSeq: field4,
      rowCount: field5,
      error: field6,
    };
    return new BopFetchResponse(message);
  }
}


export interface IBopStoreRequest extends BebopRecord {

  readonly nodes: Array<Uint8Array>;

  readonly sourcePublicKey: Uint8Array;

  readonly targetPublicKey: Uint8Array;

  readonly muteMsgIds: Array<Uint8Array>;

  readonly preserveTransient: boolean;

  readonly batchId: number;

  readonly hasMore: boolean;
}

export class BopStoreRequest implements IBopStoreRequest {
  public static readonly opcode: number = 0x3 as 0x3;
  public readonly nodes: Array<Uint8Array>;
  public readonly sourcePublicKey: Uint8Array;
  public readonly targetPublicKey: Uint8Array;
  public readonly muteMsgIds: Array<Uint8Array>;
  public readonly preserveTransient: boolean;
  public readonly batchId: number;
  public readonly hasMore: boolean;

  constructor(record: IBopStoreRequest) {
    this.nodes = record.nodes;
    this.sourcePublicKey = record.sourcePublicKey;
    this.targetPublicKey = record.targetPublicKey;
    this.muteMsgIds = record.muteMsgIds;
    this.preserveTransient = record.preserveTransient;
    this.batchId = record.batchId;
    this.hasMore = record.hasMore;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopStoreRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopStoreRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopStoreRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopStoreRequest}.
   */
  public static validateCompatibility(record: IBopStoreRequest): void {
    BebopTypeGuard.ensureArray(record.nodes, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureUint8));
    BebopTypeGuard.ensureArray(record.sourcePublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.targetPublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.muteMsgIds, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureUint8));
    BebopTypeGuard.ensureBoolean(record.preserveTransient)
    BebopTypeGuard.ensureUint32(record.batchId)
    BebopTypeGuard.ensureBoolean(record.hasMore)
  }

  /**
   * Unsafely creates an instance of {@link BopStoreRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopStoreRequest {
      return new BopStoreRequest(record);
  }

  /**
   * Creates a new {@link BopStoreRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopStoreRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopStoreRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopStoreRequest.validateCompatibility(parsed);
    return BopStoreRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopStoreRequest.encode(this);
  }

  public static encode(record: IBopStoreRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopStoreRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopStoreRequest, view: BebopView): number {
    const before = view.length;
    {
      const length0 = record.nodes.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeBytes(record.nodes[i0]);
      }
    }
    view.writeBytes(record.sourcePublicKey);
    view.writeBytes(record.targetPublicKey);
    {
      const length0 = record.muteMsgIds.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeBytes(record.muteMsgIds[i0]);
      }
    }
    view.writeByte(Number(record.preserveTransient));
    view.writeUint32(record.batchId);
    view.writeByte(Number(record.hasMore));
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopStoreRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopStoreRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopStoreRequest {
    let field0: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field0 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field0[i0] = x0;
      }
    }
    let field1: Uint8Array;
    field1 = view.readBytes();
    let field2: Uint8Array;
    field2 = view.readBytes();
    let field3: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field3 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field3[i0] = x0;
      }
    }
    let field4: boolean;
    field4 = !!view.readByte();
    let field5: number;
    field5 = view.readUint32();
    let field6: boolean;
    field6 = !!view.readByte();
    let message: IBopStoreRequest = {
      nodes: field0,
      sourcePublicKey: field1,
      targetPublicKey: field2,
      muteMsgIds: field3,
      preserveTransient: field4,
      batchId: field5,
      hasMore: field6,
    };
    return new BopStoreRequest(message);
  }
}


export interface IBopStoreResponse extends BebopRecord {

  readonly status: Status;

  readonly storedId1List: Array<Uint8Array>;

  readonly missingBlobId1List: Array<Uint8Array>;

  readonly missingBlobSizes: Array<bigint>;

  readonly error: string;
}

export class BopStoreResponse implements IBopStoreResponse {
  public static readonly opcode: number = 0x4 as 0x4;
  public readonly status: Status;
  public readonly storedId1List: Array<Uint8Array>;
  public readonly missingBlobId1List: Array<Uint8Array>;
  public readonly missingBlobSizes: Array<bigint>;
  public readonly error: string;

  constructor(record: IBopStoreResponse) {
    this.status = record.status;
    this.storedId1List = record.storedId1List;
    this.missingBlobId1List = record.missingBlobId1List;
    this.missingBlobSizes = record.missingBlobSizes;
    this.error = record.error;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopStoreResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopStoreResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopStoreResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopStoreResponse}.
   */
  public static validateCompatibility(record: IBopStoreResponse): void {
    BebopTypeGuard.ensureEnum(record.status, Status);
    BebopTypeGuard.ensureArray(record.storedId1List, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureUint8));
    BebopTypeGuard.ensureArray(record.missingBlobId1List, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureUint8));
    BebopTypeGuard.ensureArray(record.missingBlobSizes, BebopTypeGuard.ensureInt64);
    BebopTypeGuard.ensureString(record.error)
  }

  /**
   * Unsafely creates an instance of {@link BopStoreResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopStoreResponse {
      return new BopStoreResponse(record);
  }

  /**
   * Creates a new {@link BopStoreResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopStoreResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopStoreResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopStoreResponse.validateCompatibility(parsed);
    return BopStoreResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopStoreResponse.encode(this);
  }

  public static encode(record: IBopStoreResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopStoreResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopStoreResponse, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.status);
    {
      const length0 = record.storedId1List.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeBytes(record.storedId1List[i0]);
      }
    }
    {
      const length0 = record.missingBlobId1List.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeBytes(record.missingBlobId1List[i0]);
      }
    }
    {
      const length0 = record.missingBlobSizes.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeInt64(record.missingBlobSizes[i0]);
      }
    }
    view.writeString(record.error);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopStoreResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopStoreResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopStoreResponse {
    let field0: Status;
    field0 = view.readUint32() as Status;
    let field1: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field1 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field1[i0] = x0;
      }
    }
    let field2: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field2 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field2[i0] = x0;
      }
    }
    let field3: Array<bigint>;
    {
      let length0 = view.readUint32();
      field3 = new Array<bigint>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: bigint;
        x0 = view.readInt64();
        field3[i0] = x0;
      }
    }
    let field4: string;
    field4 = view.readString();
    let message: IBopStoreResponse = {
      status: field0,
      storedId1List: field1,
      missingBlobId1List: field2,
      missingBlobSizes: field3,
      error: field4,
    };
    return new BopStoreResponse(message);
  }
}


export interface IBopUnsubscribeRequest extends BebopRecord {

  readonly originalMsgId: Uint8Array;

  readonly targetPublicKey: Uint8Array;
}

export class BopUnsubscribeRequest implements IBopUnsubscribeRequest {
  public static readonly opcode: number = 0x5 as 0x5;
  public readonly originalMsgId: Uint8Array;
  public readonly targetPublicKey: Uint8Array;

  constructor(record: IBopUnsubscribeRequest) {
    this.originalMsgId = record.originalMsgId;
    this.targetPublicKey = record.targetPublicKey;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopUnsubscribeRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopUnsubscribeRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopUnsubscribeRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopUnsubscribeRequest}.
   */
  public static validateCompatibility(record: IBopUnsubscribeRequest): void {
    BebopTypeGuard.ensureArray(record.originalMsgId, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.targetPublicKey, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link BopUnsubscribeRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopUnsubscribeRequest {
      return new BopUnsubscribeRequest(record);
  }

  /**
   * Creates a new {@link BopUnsubscribeRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopUnsubscribeRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopUnsubscribeRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopUnsubscribeRequest.validateCompatibility(parsed);
    return BopUnsubscribeRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopUnsubscribeRequest.encode(this);
  }

  public static encode(record: IBopUnsubscribeRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopUnsubscribeRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopUnsubscribeRequest, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.originalMsgId);
    view.writeBytes(record.targetPublicKey);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopUnsubscribeRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopUnsubscribeRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopUnsubscribeRequest {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Uint8Array;
    field1 = view.readBytes();
    let message: IBopUnsubscribeRequest = {
      originalMsgId: field0,
      targetPublicKey: field1,
    };
    return new BopUnsubscribeRequest(message);
  }
}


export interface IBopUnsubscribeResponse extends BebopRecord {

  readonly status: Status;

  readonly error: string;
}

export class BopUnsubscribeResponse implements IBopUnsubscribeResponse {
  public static readonly opcode: number = 0x6 as 0x6;
  public readonly status: Status;
  public readonly error: string;

  constructor(record: IBopUnsubscribeResponse) {
    this.status = record.status;
    this.error = record.error;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopUnsubscribeResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopUnsubscribeResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopUnsubscribeResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopUnsubscribeResponse}.
   */
  public static validateCompatibility(record: IBopUnsubscribeResponse): void {
    BebopTypeGuard.ensureEnum(record.status, Status);
    BebopTypeGuard.ensureString(record.error)
  }

  /**
   * Unsafely creates an instance of {@link BopUnsubscribeResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopUnsubscribeResponse {
      return new BopUnsubscribeResponse(record);
  }

  /**
   * Creates a new {@link BopUnsubscribeResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopUnsubscribeResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopUnsubscribeResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopUnsubscribeResponse.validateCompatibility(parsed);
    return BopUnsubscribeResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopUnsubscribeResponse.encode(this);
  }

  public static encode(record: IBopUnsubscribeResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopUnsubscribeResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopUnsubscribeResponse, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.status);
    view.writeString(record.error);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopUnsubscribeResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopUnsubscribeResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopUnsubscribeResponse {
    let field0: Status;
    field0 = view.readUint32() as Status;
    let field1: string;
    field1 = view.readString();
    let message: IBopUnsubscribeResponse = {
      status: field0,
      error: field1,
    };
    return new BopUnsubscribeResponse(message);
  }
}


export interface IBopWriteBlobRequest extends BebopRecord {

  readonly nodeId1: Uint8Array;

  readonly pos: bigint;

  readonly data: Uint8Array;

  readonly sourcePublicKey: Uint8Array;

  readonly targetPublicKey: Uint8Array;

  readonly muteMsgIds: Array<Uint8Array>;
}

export class BopWriteBlobRequest implements IBopWriteBlobRequest {
  public static readonly opcode: number = 0x7 as 0x7;
  public readonly nodeId1: Uint8Array;
  public readonly pos: bigint;
  public readonly data: Uint8Array;
  public readonly sourcePublicKey: Uint8Array;
  public readonly targetPublicKey: Uint8Array;
  public readonly muteMsgIds: Array<Uint8Array>;

  constructor(record: IBopWriteBlobRequest) {
    this.nodeId1 = record.nodeId1;
    this.pos = record.pos;
    this.data = record.data;
    this.sourcePublicKey = record.sourcePublicKey;
    this.targetPublicKey = record.targetPublicKey;
    this.muteMsgIds = record.muteMsgIds;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopWriteBlobRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopWriteBlobRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopWriteBlobRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopWriteBlobRequest}.
   */
  public static validateCompatibility(record: IBopWriteBlobRequest): void {
    BebopTypeGuard.ensureArray(record.nodeId1, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureUint64(record.pos)
    BebopTypeGuard.ensureArray(record.data, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.sourcePublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.targetPublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.muteMsgIds, (element) => BebopTypeGuard.ensureArray(element, BebopTypeGuard.ensureUint8));
  }

  /**
   * Unsafely creates an instance of {@link BopWriteBlobRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopWriteBlobRequest {
      return new BopWriteBlobRequest(record);
  }

  /**
   * Creates a new {@link BopWriteBlobRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopWriteBlobRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopWriteBlobRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopWriteBlobRequest.validateCompatibility(parsed);
    return BopWriteBlobRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopWriteBlobRequest.encode(this);
  }

  public static encode(record: IBopWriteBlobRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopWriteBlobRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopWriteBlobRequest, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.nodeId1);
    view.writeUint64(record.pos);
    view.writeBytes(record.data);
    view.writeBytes(record.sourcePublicKey);
    view.writeBytes(record.targetPublicKey);
    {
      const length0 = record.muteMsgIds.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeBytes(record.muteMsgIds[i0]);
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopWriteBlobRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopWriteBlobRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopWriteBlobRequest {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: Uint8Array;
    field2 = view.readBytes();
    let field3: Uint8Array;
    field3 = view.readBytes();
    let field4: Uint8Array;
    field4 = view.readBytes();
    let field5: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field5 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field5[i0] = x0;
      }
    }
    let message: IBopWriteBlobRequest = {
      nodeId1: field0,
      pos: field1,
      data: field2,
      sourcePublicKey: field3,
      targetPublicKey: field4,
      muteMsgIds: field5,
    };
    return new BopWriteBlobRequest(message);
  }
}


export interface IBopWriteBlobResponse extends BebopRecord {

  readonly status: Status;

  readonly currentLength: bigint;

  readonly error: string;
}

export class BopWriteBlobResponse implements IBopWriteBlobResponse {
  public static readonly opcode: number = 0x8 as 0x8;
  public readonly status: Status;
  public readonly currentLength: bigint;
  public readonly error: string;

  constructor(record: IBopWriteBlobResponse) {
    this.status = record.status;
    this.currentLength = record.currentLength;
    this.error = record.error;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopWriteBlobResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopWriteBlobResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopWriteBlobResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopWriteBlobResponse}.
   */
  public static validateCompatibility(record: IBopWriteBlobResponse): void {
    BebopTypeGuard.ensureEnum(record.status, Status);
    BebopTypeGuard.ensureUint64(record.currentLength)
    BebopTypeGuard.ensureString(record.error)
  }

  /**
   * Unsafely creates an instance of {@link BopWriteBlobResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopWriteBlobResponse {
      return new BopWriteBlobResponse(record);
  }

  /**
   * Creates a new {@link BopWriteBlobResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopWriteBlobResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopWriteBlobResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopWriteBlobResponse.validateCompatibility(parsed);
    return BopWriteBlobResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopWriteBlobResponse.encode(this);
  }

  public static encode(record: IBopWriteBlobResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopWriteBlobResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopWriteBlobResponse, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.status);
    view.writeUint64(record.currentLength);
    view.writeString(record.error);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopWriteBlobResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopWriteBlobResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopWriteBlobResponse {
    let field0: Status;
    field0 = view.readUint32() as Status;
    let field1: bigint;
    field1 = view.readUint64();
    let field2: string;
    field2 = view.readString();
    let message: IBopWriteBlobResponse = {
      status: field0,
      currentLength: field1,
      error: field2,
    };
    return new BopWriteBlobResponse(message);
  }
}


export interface IBopReadBlobRequest extends BebopRecord {

  readonly nodeId1: Uint8Array;

  readonly pos: bigint;

  readonly length: number;

  readonly targetPublicKey: Uint8Array;

  readonly sourcePublicKey: Uint8Array;
}

export class BopReadBlobRequest implements IBopReadBlobRequest {
  public static readonly opcode: number = 0x9 as 0x9;
  public readonly nodeId1: Uint8Array;
  public readonly pos: bigint;
  public readonly length: number;
  public readonly targetPublicKey: Uint8Array;
  public readonly sourcePublicKey: Uint8Array;

  constructor(record: IBopReadBlobRequest) {
    this.nodeId1 = record.nodeId1;
    this.pos = record.pos;
    this.length = record.length;
    this.targetPublicKey = record.targetPublicKey;
    this.sourcePublicKey = record.sourcePublicKey;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopReadBlobRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopReadBlobRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopReadBlobRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopReadBlobRequest}.
   */
  public static validateCompatibility(record: IBopReadBlobRequest): void {
    BebopTypeGuard.ensureArray(record.nodeId1, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureUint64(record.pos)
    BebopTypeGuard.ensureUint32(record.length)
    BebopTypeGuard.ensureArray(record.targetPublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.sourcePublicKey, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link BopReadBlobRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopReadBlobRequest {
      return new BopReadBlobRequest(record);
  }

  /**
   * Creates a new {@link BopReadBlobRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopReadBlobRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopReadBlobRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopReadBlobRequest.validateCompatibility(parsed);
    return BopReadBlobRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopReadBlobRequest.encode(this);
  }

  public static encode(record: IBopReadBlobRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopReadBlobRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopReadBlobRequest, view: BebopView): number {
    const before = view.length;
    view.writeBytes(record.nodeId1);
    view.writeUint64(record.pos);
    view.writeUint32(record.length);
    view.writeBytes(record.targetPublicKey);
    view.writeBytes(record.sourcePublicKey);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopReadBlobRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopReadBlobRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopReadBlobRequest {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readUint32();
    let field3: Uint8Array;
    field3 = view.readBytes();
    let field4: Uint8Array;
    field4 = view.readBytes();
    let message: IBopReadBlobRequest = {
      nodeId1: field0,
      pos: field1,
      length: field2,
      targetPublicKey: field3,
      sourcePublicKey: field4,
    };
    return new BopReadBlobRequest(message);
  }
}


export interface IBopReadBlobResponse extends BebopRecord {

  readonly status: Status;

  readonly data: Uint8Array;

  readonly seq: number;

  readonly endSeq: number;

  readonly blobLength: bigint;

  readonly error: string;
}

export class BopReadBlobResponse implements IBopReadBlobResponse {
  public static readonly opcode: number = 0xA as 0xA;
  public readonly status: Status;
  public readonly data: Uint8Array;
  public readonly seq: number;
  public readonly endSeq: number;
  public readonly blobLength: bigint;
  public readonly error: string;

  constructor(record: IBopReadBlobResponse) {
    this.status = record.status;
    this.data = record.data;
    this.seq = record.seq;
    this.endSeq = record.endSeq;
    this.blobLength = record.blobLength;
    this.error = record.error;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopReadBlobResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopReadBlobResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopReadBlobResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopReadBlobResponse}.
   */
  public static validateCompatibility(record: IBopReadBlobResponse): void {
    BebopTypeGuard.ensureEnum(record.status, Status);
    BebopTypeGuard.ensureArray(record.data, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureUint16(record.seq)
    BebopTypeGuard.ensureUint16(record.endSeq)
    BebopTypeGuard.ensureUint64(record.blobLength)
    BebopTypeGuard.ensureString(record.error)
  }

  /**
   * Unsafely creates an instance of {@link BopReadBlobResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopReadBlobResponse {
      return new BopReadBlobResponse(record);
  }

  /**
   * Creates a new {@link BopReadBlobResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopReadBlobResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopReadBlobResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopReadBlobResponse.validateCompatibility(parsed);
    return BopReadBlobResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopReadBlobResponse.encode(this);
  }

  public static encode(record: IBopReadBlobResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopReadBlobResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopReadBlobResponse, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.status);
    view.writeBytes(record.data);
    view.writeUint16(record.seq);
    view.writeUint16(record.endSeq);
    view.writeUint64(record.blobLength);
    view.writeString(record.error);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopReadBlobResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopReadBlobResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopReadBlobResponse {
    let field0: Status;
    field0 = view.readUint32() as Status;
    let field1: Uint8Array;
    field1 = view.readBytes();
    let field2: number;
    field2 = view.readUint16();
    let field3: number;
    field3 = view.readUint16();
    let field4: bigint;
    field4 = view.readUint64();
    let field5: string;
    field5 = view.readString();
    let message: IBopReadBlobResponse = {
      status: field0,
      data: field1,
      seq: field2,
      endSeq: field3,
      blobLength: field4,
      error: field5,
    };
    return new BopReadBlobResponse(message);
  }
}


export interface IBopGenericMessageRequest extends BebopRecord {

  readonly action: string;

  readonly sourcePublicKey: Uint8Array;

  readonly data: Uint8Array;
}

export class BopGenericMessageRequest implements IBopGenericMessageRequest {
  public static readonly opcode: number = 0xB as 0xB;
  public readonly action: string;
  public readonly sourcePublicKey: Uint8Array;
  public readonly data: Uint8Array;

  constructor(record: IBopGenericMessageRequest) {
    this.action = record.action;
    this.sourcePublicKey = record.sourcePublicKey;
    this.data = record.data;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopGenericMessageRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopGenericMessageRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopGenericMessageRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopGenericMessageRequest}.
   */
  public static validateCompatibility(record: IBopGenericMessageRequest): void {
    BebopTypeGuard.ensureString(record.action)
    BebopTypeGuard.ensureArray(record.sourcePublicKey, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureArray(record.data, BebopTypeGuard.ensureUint8);
  }

  /**
   * Unsafely creates an instance of {@link BopGenericMessageRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopGenericMessageRequest {
      return new BopGenericMessageRequest(record);
  }

  /**
   * Creates a new {@link BopGenericMessageRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopGenericMessageRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopGenericMessageRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopGenericMessageRequest.validateCompatibility(parsed);
    return BopGenericMessageRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopGenericMessageRequest.encode(this);
  }

  public static encode(record: IBopGenericMessageRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopGenericMessageRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopGenericMessageRequest, view: BebopView): number {
    const before = view.length;
    view.writeString(record.action);
    view.writeBytes(record.sourcePublicKey);
    view.writeBytes(record.data);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopGenericMessageRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopGenericMessageRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopGenericMessageRequest {
    let field0: string;
    field0 = view.readString();
    let field1: Uint8Array;
    field1 = view.readBytes();
    let field2: Uint8Array;
    field2 = view.readBytes();
    let message: IBopGenericMessageRequest = {
      action: field0,
      sourcePublicKey: field1,
      data: field2,
    };
    return new BopGenericMessageRequest(message);
  }
}


export interface IBopGenericMessageResponse extends BebopRecord {

  readonly status: Status;

  readonly data: Uint8Array;

  readonly error: string;
}

export class BopGenericMessageResponse implements IBopGenericMessageResponse {
  public static readonly opcode: number = 0xC as 0xC;
  public readonly status: Status;
  public readonly data: Uint8Array;
  public readonly error: string;

  constructor(record: IBopGenericMessageResponse) {
    this.status = record.status;
    this.data = record.data;
    this.error = record.error;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return BopGenericMessageResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IBopGenericMessageResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    BopGenericMessageResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link BopGenericMessageResponse}.
   */
  public static validateCompatibility(record: IBopGenericMessageResponse): void {
    BebopTypeGuard.ensureEnum(record.status, Status);
    BebopTypeGuard.ensureArray(record.data, BebopTypeGuard.ensureUint8);
    BebopTypeGuard.ensureString(record.error)
  }

  /**
   * Unsafely creates an instance of {@link BopGenericMessageResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IBopGenericMessageResponse {
      return new BopGenericMessageResponse(record);
  }

  /**
   * Creates a new {@link BopGenericMessageResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IBopGenericMessageResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`BopGenericMessageResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    BopGenericMessageResponse.validateCompatibility(parsed);
    return BopGenericMessageResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return BopGenericMessageResponse.encode(this);
  }

  public static encode(record: IBopGenericMessageResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    BopGenericMessageResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IBopGenericMessageResponse, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.status);
    view.writeBytes(record.data);
    view.writeString(record.error);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IBopGenericMessageResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return BopGenericMessageResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IBopGenericMessageResponse {
    let field0: Status;
    field0 = view.readUint32() as Status;
    let field1: Uint8Array;
    field1 = view.readBytes();
    let field2: string;
    field2 = view.readString();
    let message: IBopGenericMessageResponse = {
      status: field0,
      data: field1,
      error: field2,
    };
    return new BopGenericMessageResponse(message);
  }
}

