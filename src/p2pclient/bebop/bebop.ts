//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.4.10
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError } from "bebop";

/**
 * These data structs are converted into TypeScript using the bebop tool: `npm run bebop`.
 * The types are used to serialize/deserialize the TypeScript structs defined in requestTypes.ts (see this file for documentation on the structs).
 * See: https://github.com/RainwayApp/bebop/wiki/Writing-Bops:-The-Bebop-Schema-Language
 */
export interface ILimitField {
  name: string;
  limit: number;
}

export const LimitField = {
  encode(message: ILimitField): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ILimitField, view: BebopView): number {
    const before = view.length;
      view.writeString(message.name);
      view.writeUint16(message.limit);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ILimitField {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ILimitField {
    let field0: string;
    field0 = view.readString();
    let field1: number;
    field1 = view.readUint16();
    let message: ILimitField = {
      name: field0,
      limit: field1,
    };
    return message;
  },
};

export interface IFilter {
  field: string;
  operator: string;
  cmp: string;
  value: Uint8Array;
}

export const Filter = {
  encode(message: IFilter): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFilter, view: BebopView): number {
    const before = view.length;
      view.writeString(message.field);
      view.writeString(message.operator);
      view.writeString(message.cmp);
      view.writeBytes(message.value);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFilter {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFilter {
    let field0: string;
    field0 = view.readString();
    let field1: string;
    field1 = view.readString();
    let field2: string;
    field2 = view.readString();
    let field3: Uint8Array;
    field3 = view.readBytes();
    let message: IFilter = {
      field: field0,
      operator: field1,
      cmp: field2,
      value: field3,
    };
    return message;
  },
};

export interface IMatch {
  nodeType: Uint8Array;
  filters: Array<IFilter>;
  limit: number;
  limitField: ILimitField;
  level: Array<number>;
  discard: boolean;
  bottom: boolean;
  id: number;
  requireId: number;
  cursorId1: Uint8Array;
}

export const Match = {
  encode(message: IMatch): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IMatch, view: BebopView): number {
    const before = view.length;
      view.writeBytes(message.nodeType);
      {
        const length0 = message.filters.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          Filter.encodeInto(message.filters[i0], view)
        }
      }
      view.writeInt32(message.limit);
      LimitField.encodeInto(message.limitField, view)
      {
        const length0 = message.level.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint16(message.level[i0]);
        }
      }
      view.writeByte(Number(message.discard));
      view.writeByte(Number(message.bottom));
      view.writeByte(message.id);
      view.writeByte(message.requireId);
      view.writeBytes(message.cursorId1);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IMatch {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IMatch {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Array<IFilter>;
    {
      let length0 = view.readUint32();
      field1 = new Array<IFilter>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IFilter;
        x0 = Filter.readFrom(view);
        field1[i0] = x0;
      }
    }
    let field2: number;
    field2 = view.readInt32();
    let field3: ILimitField;
    field3 = LimitField.readFrom(view);
    let field4: Array<number>;
    {
      let length0 = view.readUint32();
      field4 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readUint16();
        field4[i0] = x0;
      }
    }
    let field5: boolean;
    field5 = !!view.readByte();
    let field6: boolean;
    field6 = !!view.readByte();
    let field7: number;
    field7 = view.readByte();
    let field8: number;
    field8 = view.readByte();
    let field9: Uint8Array;
    field9 = view.readBytes();
    let message: IMatch = {
      nodeType: field0,
      filters: field1,
      limit: field2,
      limitField: field3,
      level: field4,
      discard: field5,
      bottom: field6,
      id: field7,
      requireId: field8,
      cursorId1: field9,
    };
    return message;
  },
};

export interface IAllowEmbed {
  nodeType: Uint8Array;
  filters: Array<IFilter>;
}

export const AllowEmbed = {
  encode(message: IAllowEmbed): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IAllowEmbed, view: BebopView): number {
    const before = view.length;
      view.writeBytes(message.nodeType);
      {
        const length0 = message.filters.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          Filter.encodeInto(message.filters[i0], view)
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IAllowEmbed {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IAllowEmbed {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: Array<IFilter>;
    {
      let length0 = view.readUint32();
      field1 = new Array<IFilter>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IFilter;
        x0 = Filter.readFrom(view);
        field1[i0] = x0;
      }
    }
    let message: IAllowEmbed = {
      nodeType: field0,
      filters: field1,
    };
    return message;
  },
};

export interface IFetchQuery {
  depth: number;
  limit: number;
  cutoffTime: bigint;
  rootNodeId1: Uint8Array;
  discardRoot: boolean;
  parentId: Uint8Array;
  targetPublicKey: Uint8Array;
  sourcePublicKey: Uint8Array;
  match: Array<IMatch>;
  embed: Array<IAllowEmbed>;
  triggerNodeId: Uint8Array;
  triggerInterval: number;
  onlyTrigger: boolean;
  descending: boolean;
  orderByStorageTime: boolean;
  ignoreInactive: boolean;
  ignoreOwn: boolean;
  preserveTransient: boolean;
  region: string;
  jurisdiction: string;
  includeLicenses: number;
}

export const FetchQuery = {
  encode(message: IFetchQuery): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFetchQuery, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.depth);
      view.writeInt32(message.limit);
      view.writeInt64(message.cutoffTime);
      view.writeBytes(message.rootNodeId1);
      view.writeByte(Number(message.discardRoot));
      view.writeBytes(message.parentId);
      view.writeBytes(message.targetPublicKey);
      view.writeBytes(message.sourcePublicKey);
      {
        const length0 = message.match.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          Match.encodeInto(message.match[i0], view)
        }
      }
      {
        const length0 = message.embed.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          AllowEmbed.encodeInto(message.embed[i0], view)
        }
      }
      view.writeBytes(message.triggerNodeId);
      view.writeUint16(message.triggerInterval);
      view.writeByte(Number(message.onlyTrigger));
      view.writeByte(Number(message.descending));
      view.writeByte(Number(message.orderByStorageTime));
      view.writeByte(Number(message.ignoreInactive));
      view.writeByte(Number(message.ignoreOwn));
      view.writeByte(Number(message.preserveTransient));
      view.writeString(message.region);
      view.writeString(message.jurisdiction);
      view.writeByte(message.includeLicenses);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFetchQuery {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFetchQuery {
    let field0: number;
    field0 = view.readInt32();
    let field1: number;
    field1 = view.readInt32();
    let field2: bigint;
    field2 = view.readInt64();
    let field3: Uint8Array;
    field3 = view.readBytes();
    let field4: boolean;
    field4 = !!view.readByte();
    let field5: Uint8Array;
    field5 = view.readBytes();
    let field6: Uint8Array;
    field6 = view.readBytes();
    let field7: Uint8Array;
    field7 = view.readBytes();
    let field8: Array<IMatch>;
    {
      let length0 = view.readUint32();
      field8 = new Array<IMatch>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IMatch;
        x0 = Match.readFrom(view);
        field8[i0] = x0;
      }
    }
    let field9: Array<IAllowEmbed>;
    {
      let length0 = view.readUint32();
      field9 = new Array<IAllowEmbed>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IAllowEmbed;
        x0 = AllowEmbed.readFrom(view);
        field9[i0] = x0;
      }
    }
    let field10: Uint8Array;
    field10 = view.readBytes();
    let field11: number;
    field11 = view.readUint16();
    let field12: boolean;
    field12 = !!view.readByte();
    let field13: boolean;
    field13 = !!view.readByte();
    let field14: boolean;
    field14 = !!view.readByte();
    let field15: boolean;
    field15 = !!view.readByte();
    let field16: boolean;
    field16 = !!view.readByte();
    let field17: boolean;
    field17 = !!view.readByte();
    let field18: string;
    field18 = view.readString();
    let field19: string;
    field19 = view.readString();
    let field20: number;
    field20 = view.readByte();
    let message: IFetchQuery = {
      depth: field0,
      limit: field1,
      cutoffTime: field2,
      rootNodeId1: field3,
      discardRoot: field4,
      parentId: field5,
      targetPublicKey: field6,
      sourcePublicKey: field7,
      match: field8,
      embed: field9,
      triggerNodeId: field10,
      triggerInterval: field11,
      onlyTrigger: field12,
      descending: field13,
      orderByStorageTime: field14,
      ignoreInactive: field15,
      ignoreOwn: field16,
      preserveTransient: field17,
      region: field18,
      jurisdiction: field19,
      includeLicenses: field20,
    };
    return message;
  },
};

export interface IFetchCRDT {
  algo: number;
  conf: string;
  msgId: Uint8Array;
  reverse: boolean;
  head: number;
  tail: number;
  cursorId1: Uint8Array;
  cursorIndex: number;
}

export const FetchCRDT = {
  encode(message: IFetchCRDT): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFetchCRDT, view: BebopView): number {
    const before = view.length;
      view.writeUint16(message.algo);
      view.writeString(message.conf);
      view.writeBytes(message.msgId);
      view.writeByte(Number(message.reverse));
      view.writeInt32(message.head);
      view.writeInt32(message.tail);
      view.writeBytes(message.cursorId1);
      view.writeInt32(message.cursorIndex);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFetchCRDT {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFetchCRDT {
    let field0: number;
    field0 = view.readUint16();
    let field1: string;
    field1 = view.readString();
    let field2: Uint8Array;
    field2 = view.readBytes();
    let field3: boolean;
    field3 = !!view.readByte();
    let field4: number;
    field4 = view.readInt32();
    let field5: number;
    field5 = view.readInt32();
    let field6: Uint8Array;
    field6 = view.readBytes();
    let field7: number;
    field7 = view.readInt32();
    let message: IFetchCRDT = {
      algo: field0,
      conf: field1,
      msgId: field2,
      reverse: field3,
      head: field4,
      tail: field5,
      cursorId1: field6,
      cursorIndex: field7,
    };
    return message;
  },
};

export enum Status {
  RESULT = 1,
  MALFORMED = 2,
  ERROR = 3,
  STORE_FAILED = 4,
  FETCH_FAILED = 5,
  MISSING_ROOTNODE = 6,
  ROOTNODE_LICENSED = 7,
  NOT_ALLOWED = 8,
  MISMATCH = 9,
  EXISTS = 10,
  MISSING_CURSOR = 11,
  DROPPED_TRIGGER = 12,
}

export interface IFetchResult {
  nodes: Array<Uint8Array>;
  embed: Array<Uint8Array>;
  cutoffTime: bigint;
}

export const FetchResult = {
  encode(message: IFetchResult): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFetchResult, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.nodes.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeBytes(message.nodes[i0]);
        }
      }
      {
        const length0 = message.embed.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeBytes(message.embed[i0]);
        }
      }
      view.writeInt64(message.cutoffTime);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFetchResult {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFetchResult {
    let field0: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field0 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field0[i0] = x0;
      }
    }
    let field1: Array<Uint8Array>;
    {
      let length0 = view.readUint32();
      field1 = new Array<Uint8Array>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Uint8Array;
        x0 = view.readBytes();
        field1[i0] = x0;
      }
    }
    let field2: bigint;
    field2 = view.readInt64();
    let message: IFetchResult = {
      nodes: field0,
      embed: field1,
      cutoffTime: field2,
    };
    return message;
  },
};

export interface ICRDTResult {
  delta: Uint8Array;
  cursorIndex: number;
  length: number;
}

export const CRDTResult = {
  encode(message: ICRDTResult): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ICRDTResult, view: BebopView): number {
    const before = view.length;
      view.writeBytes(message.delta);
      view.writeInt32(message.cursorIndex);
      view.writeUint32(message.length);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ICRDTResult {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ICRDTResult {
    let field0: Uint8Array;
    field0 = view.readBytes();
    let field1: number;
    field1 = view.readInt32();
    let field2: number;
    field2 = view.readUint32();
    let message: ICRDTResult = {
      delta: field0,
      cursorIndex: field1,
      length: field2,
    };
    return message;
  },
};

export interface IBopFetchRequest {
  query?: IFetchQuery;
  crdt?: IFetchCRDT;
}

export const BopFetchRequest = {
  opcode: 0x1,
  encode(message: IBopFetchRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopFetchRequest, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.query != null) {
        view.writeByte(1);
        FetchQuery.encodeInto(message.query, view)
      }
      if (message.crdt != null) {
        view.writeByte(2);
        FetchCRDT.encodeInto(message.crdt, view)
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopFetchRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopFetchRequest {
    let message: IBopFetchRequest = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.query = FetchQuery.readFrom(view);
          break;

        case 2:
          message.crdt = FetchCRDT.readFrom(view);
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopFetchResponse {
  status?: Status;
  result?: IFetchResult;
  crdtResult?: ICRDTResult;
  seq?: number;
  endSeq?: number;
  rowCount?: number;
  error?: string;
}

export const BopFetchResponse = {
  opcode: 0x2,
  encode(message: IBopFetchResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopFetchResponse, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.status != null) {
        view.writeByte(1);
        view.writeUint32(message.status);
      }
      if (message.result != null) {
        view.writeByte(2);
        FetchResult.encodeInto(message.result, view)
      }
      if (message.crdtResult != null) {
        view.writeByte(3);
        CRDTResult.encodeInto(message.crdtResult, view)
      }
      if (message.seq != null) {
        view.writeByte(4);
        view.writeUint16(message.seq);
      }
      if (message.endSeq != null) {
        view.writeByte(5);
        view.writeUint16(message.endSeq);
      }
      if (message.rowCount != null) {
        view.writeByte(6);
        view.writeUint16(message.rowCount);
      }
      if (message.error != null) {
        view.writeByte(7);
        view.writeString(message.error);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopFetchResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopFetchResponse {
    let message: IBopFetchResponse = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.status = view.readUint32() as Status;
          break;

        case 2:
          message.result = FetchResult.readFrom(view);
          break;

        case 3:
          message.crdtResult = CRDTResult.readFrom(view);
          break;

        case 4:
          message.seq = view.readUint16();
          break;

        case 5:
          message.endSeq = view.readUint16();
          break;

        case 6:
          message.rowCount = view.readUint16();
          break;

        case 7:
          message.error = view.readString();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopStoreRequest {
  nodes?: Array<Uint8Array>;
  sourcePublicKey?: Uint8Array;
  targetPublicKey?: Uint8Array;
  muteMsgIds?: Array<Uint8Array>;
  preserveTransient?: boolean;
  batchId?: number;
  hasMore?: boolean;
}

export const BopStoreRequest = {
  opcode: 0x3,
  encode(message: IBopStoreRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopStoreRequest, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.nodes != null) {
        view.writeByte(1);
        {
        const length0 = message.nodes.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeBytes(message.nodes[i0]);
        }
      }
      }
      if (message.sourcePublicKey != null) {
        view.writeByte(2);
        view.writeBytes(message.sourcePublicKey);
      }
      if (message.targetPublicKey != null) {
        view.writeByte(3);
        view.writeBytes(message.targetPublicKey);
      }
      if (message.muteMsgIds != null) {
        view.writeByte(4);
        {
        const length0 = message.muteMsgIds.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeBytes(message.muteMsgIds[i0]);
        }
      }
      }
      if (message.preserveTransient != null) {
        view.writeByte(5);
        view.writeByte(Number(message.preserveTransient));
      }
      if (message.batchId != null) {
        view.writeByte(6);
        view.writeUint32(message.batchId);
      }
      if (message.hasMore != null) {
        view.writeByte(7);
        view.writeByte(Number(message.hasMore));
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopStoreRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopStoreRequest {
    let message: IBopStoreRequest = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          {
        let length0 = view.readUint32();
        message.nodes = new Array<Uint8Array>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: Uint8Array;
          x0 = view.readBytes();
          message.nodes[i0] = x0;
        }
      }
          break;

        case 2:
          message.sourcePublicKey = view.readBytes();
          break;

        case 3:
          message.targetPublicKey = view.readBytes();
          break;

        case 4:
          {
        let length0 = view.readUint32();
        message.muteMsgIds = new Array<Uint8Array>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: Uint8Array;
          x0 = view.readBytes();
          message.muteMsgIds[i0] = x0;
        }
      }
          break;

        case 5:
          message.preserveTransient = !!view.readByte();
          break;

        case 6:
          message.batchId = view.readUint32();
          break;

        case 7:
          message.hasMore = !!view.readByte();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopStoreResponse {
  status?: Status;
  storedId1S?: Array<Uint8Array>;
  missingBlobId1S?: Array<Uint8Array>;
  missingBlobSizes?: Array<bigint>;
  error?: string;
}

export const BopStoreResponse = {
  opcode: 0x4,
  encode(message: IBopStoreResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopStoreResponse, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.status != null) {
        view.writeByte(1);
        view.writeUint32(message.status);
      }
      if (message.storedId1S != null) {
        view.writeByte(2);
        {
        const length0 = message.storedId1S.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeBytes(message.storedId1S[i0]);
        }
      }
      }
      if (message.missingBlobId1S != null) {
        view.writeByte(3);
        {
        const length0 = message.missingBlobId1S.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeBytes(message.missingBlobId1S[i0]);
        }
      }
      }
      if (message.missingBlobSizes != null) {
        view.writeByte(4);
        {
        const length0 = message.missingBlobSizes.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt64(message.missingBlobSizes[i0]);
        }
      }
      }
      if (message.error != null) {
        view.writeByte(5);
        view.writeString(message.error);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopStoreResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopStoreResponse {
    let message: IBopStoreResponse = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.status = view.readUint32() as Status;
          break;

        case 2:
          {
        let length0 = view.readUint32();
        message.storedId1S = new Array<Uint8Array>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: Uint8Array;
          x0 = view.readBytes();
          message.storedId1S[i0] = x0;
        }
      }
          break;

        case 3:
          {
        let length0 = view.readUint32();
        message.missingBlobId1S = new Array<Uint8Array>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: Uint8Array;
          x0 = view.readBytes();
          message.missingBlobId1S[i0] = x0;
        }
      }
          break;

        case 4:
          {
        let length0 = view.readUint32();
        message.missingBlobSizes = new Array<bigint>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: bigint;
          x0 = view.readInt64();
          message.missingBlobSizes[i0] = x0;
        }
      }
          break;

        case 5:
          message.error = view.readString();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopUnsubscribeRequest {
  originalMsgId?: Uint8Array;
  targetPublicKey?: Uint8Array;
}

export const BopUnsubscribeRequest = {
  opcode: 0x5,
  encode(message: IBopUnsubscribeRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopUnsubscribeRequest, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.originalMsgId != null) {
        view.writeByte(1);
        view.writeBytes(message.originalMsgId);
      }
      if (message.targetPublicKey != null) {
        view.writeByte(2);
        view.writeBytes(message.targetPublicKey);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopUnsubscribeRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopUnsubscribeRequest {
    let message: IBopUnsubscribeRequest = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.originalMsgId = view.readBytes();
          break;

        case 2:
          message.targetPublicKey = view.readBytes();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopUnsubscribeResponse {
  status?: Status;
  error?: string;
}

export const BopUnsubscribeResponse = {
  opcode: 0x6,
  encode(message: IBopUnsubscribeResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopUnsubscribeResponse, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.status != null) {
        view.writeByte(1);
        view.writeUint32(message.status);
      }
      if (message.error != null) {
        view.writeByte(2);
        view.writeString(message.error);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopUnsubscribeResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopUnsubscribeResponse {
    let message: IBopUnsubscribeResponse = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.status = view.readUint32() as Status;
          break;

        case 2:
          message.error = view.readString();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopWriteBlobRequest {
  nodeId1?: Uint8Array;
  sourcePublicKey?: Uint8Array;
  targetPublicKey?: Uint8Array;
  data?: Uint8Array;
  pos?: bigint;
  muteMsgIds?: Array<Uint8Array>;
}

export const BopWriteBlobRequest = {
  opcode: 0x7,
  encode(message: IBopWriteBlobRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopWriteBlobRequest, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.nodeId1 != null) {
        view.writeByte(1);
        view.writeBytes(message.nodeId1);
      }
      if (message.sourcePublicKey != null) {
        view.writeByte(2);
        view.writeBytes(message.sourcePublicKey);
      }
      if (message.targetPublicKey != null) {
        view.writeByte(3);
        view.writeBytes(message.targetPublicKey);
      }
      if (message.data != null) {
        view.writeByte(4);
        view.writeBytes(message.data);
      }
      if (message.pos != null) {
        view.writeByte(5);
        view.writeUint64(message.pos);
      }
      if (message.muteMsgIds != null) {
        view.writeByte(6);
        {
        const length0 = message.muteMsgIds.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeBytes(message.muteMsgIds[i0]);
        }
      }
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopWriteBlobRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopWriteBlobRequest {
    let message: IBopWriteBlobRequest = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.nodeId1 = view.readBytes();
          break;

        case 2:
          message.sourcePublicKey = view.readBytes();
          break;

        case 3:
          message.targetPublicKey = view.readBytes();
          break;

        case 4:
          message.data = view.readBytes();
          break;

        case 5:
          message.pos = view.readUint64();
          break;

        case 6:
          {
        let length0 = view.readUint32();
        message.muteMsgIds = new Array<Uint8Array>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: Uint8Array;
          x0 = view.readBytes();
          message.muteMsgIds[i0] = x0;
        }
      }
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopWriteBlobResponse {
  status?: Status;
  currentLength?: bigint;
  error?: string;
}

export const BopWriteBlobResponse = {
  opcode: 0x8,
  encode(message: IBopWriteBlobResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopWriteBlobResponse, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.status != null) {
        view.writeByte(1);
        view.writeUint32(message.status);
      }
      if (message.currentLength != null) {
        view.writeByte(2);
        view.writeUint64(message.currentLength);
      }
      if (message.error != null) {
        view.writeByte(3);
        view.writeString(message.error);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopWriteBlobResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopWriteBlobResponse {
    let message: IBopWriteBlobResponse = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.status = view.readUint32() as Status;
          break;

        case 2:
          message.currentLength = view.readUint64();
          break;

        case 3:
          message.error = view.readString();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopReadBlobRequest {
  nodeId1?: Uint8Array;
  targetPublicKey?: Uint8Array;
  sourcePublicKey?: Uint8Array;
  pos?: bigint;
  length?: number;
}

export const BopReadBlobRequest = {
  opcode: 0x9,
  encode(message: IBopReadBlobRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopReadBlobRequest, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.nodeId1 != null) {
        view.writeByte(1);
        view.writeBytes(message.nodeId1);
      }
      if (message.targetPublicKey != null) {
        view.writeByte(2);
        view.writeBytes(message.targetPublicKey);
      }
      if (message.sourcePublicKey != null) {
        view.writeByte(3);
        view.writeBytes(message.sourcePublicKey);
      }
      if (message.pos != null) {
        view.writeByte(4);
        view.writeUint64(message.pos);
      }
      if (message.length != null) {
        view.writeByte(5);
        view.writeUint32(message.length);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopReadBlobRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopReadBlobRequest {
    let message: IBopReadBlobRequest = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.nodeId1 = view.readBytes();
          break;

        case 2:
          message.targetPublicKey = view.readBytes();
          break;

        case 3:
          message.sourcePublicKey = view.readBytes();
          break;

        case 4:
          message.pos = view.readUint64();
          break;

        case 5:
          message.length = view.readUint32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopReadBlobResponse {
  status?: Status;
  data?: Uint8Array;
  seq?: number;
  endSeq?: number;
  blobLength?: bigint;
  error?: string;
}

export const BopReadBlobResponse = {
  opcode: 0xA,
  encode(message: IBopReadBlobResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopReadBlobResponse, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.status != null) {
        view.writeByte(1);
        view.writeUint32(message.status);
      }
      if (message.data != null) {
        view.writeByte(2);
        view.writeBytes(message.data);
      }
      if (message.seq != null) {
        view.writeByte(3);
        view.writeUint16(message.seq);
      }
      if (message.endSeq != null) {
        view.writeByte(4);
        view.writeUint16(message.endSeq);
      }
      if (message.blobLength != null) {
        view.writeByte(5);
        view.writeUint64(message.blobLength);
      }
      if (message.error != null) {
        view.writeByte(6);
        view.writeString(message.error);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopReadBlobResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopReadBlobResponse {
    let message: IBopReadBlobResponse = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.status = view.readUint32() as Status;
          break;

        case 2:
          message.data = view.readBytes();
          break;

        case 3:
          message.seq = view.readUint16();
          break;

        case 4:
          message.endSeq = view.readUint16();
          break;

        case 5:
          message.blobLength = view.readUint64();
          break;

        case 6:
          message.error = view.readString();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopGenericMessageRequest {
  action?: string;
  sourcePublicKey?: Uint8Array;
  data?: Uint8Array;
}

export const BopGenericMessageRequest = {
  opcode: 0xB,
  encode(message: IBopGenericMessageRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopGenericMessageRequest, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.action != null) {
        view.writeByte(1);
        view.writeString(message.action);
      }
      if (message.sourcePublicKey != null) {
        view.writeByte(2);
        view.writeBytes(message.sourcePublicKey);
      }
      if (message.data != null) {
        view.writeByte(3);
        view.writeBytes(message.data);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopGenericMessageRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopGenericMessageRequest {
    let message: IBopGenericMessageRequest = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.action = view.readString();
          break;

        case 2:
          message.sourcePublicKey = view.readBytes();
          break;

        case 3:
          message.data = view.readBytes();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IBopGenericMessageResponse {
  status?: Status;
  data?: Uint8Array;
  error?: string;
}

export const BopGenericMessageResponse = {
  opcode: 0xC,
  encode(message: IBopGenericMessageResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBopGenericMessageResponse, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.status != null) {
        view.writeByte(1);
        view.writeUint32(message.status);
      }
      if (message.data != null) {
        view.writeByte(2);
        view.writeBytes(message.data);
      }
      if (message.error != null) {
        view.writeByte(3);
        view.writeString(message.error);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBopGenericMessageResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBopGenericMessageResponse {
    let message: IBopGenericMessageResponse = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.status = view.readUint32() as Status;
          break;

        case 2:
          message.data = view.readBytes();
          break;

        case 3:
          message.error = view.readString();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

